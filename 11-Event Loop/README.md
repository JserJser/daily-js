## Event Loop
> 事件循环

****

### 进程和线程
> process && thread

官方一点的说法：进程是 CPU 资源分配的最小单位, 线程是 CPU 调度的最小单位
通俗一点：进程是部门领导, 管着众多线程员工.

### 单线程好处

1. 避免依赖没有加载完成, 
如果工作线是: 产品经理 -> UI -> 前端 + 后端 -> 测试 -> 产品经理, 
测试工程师测试产品的时候, 不知道前后端还没完成或者完善好, 可能就给产品经理报了一堆的 bug, 那产品经理对你的印象就不好了.

2. 节约了上下文切换时间

3. 没有锁的问题


### 执行栈

执行栈, 在其他编程语言里也被叫做**调用栈**, 是一种存储函数调用环境的栈结构, 后进先出(LIFO)

当开始执行 js 代码时, 首先会执行一个包含全局环境的 main 函数, 然后执行我们的代码.

**爆栈**: 使用递归时, 栈可存放的函数是有限制的, 一旦存放过多没有释放, 就会出现爆栈问题.

#### Event Loop

1. js 自上而下解析, 将其中的同步任务按照执行顺序排列到执行栈中
2. 程序调用外部 api , 如 ajax, setTimeout 等, 会将此类异步任务排列到 Event Table 中, 继续执行栈中的任务
3. 当异步函数指定事件完成后, 将回调函数放到 事件队列(Event Queue) 中
4. 主线程将执行栈中的同步任务执行完, 检查 事件队列 中是否有任务,
 - 如果有, 将第一个事件对应的回调函数推送到执行栈中执行, 如果执行过程中遇到异步任务, 则继续将这个异步任务排列到事件队列中.
 - 如果没有, 执行栈清空, 执行结束.
5. 主线程每次执行栈清空, 就去事件队列检查是否有任务, 如果有, 就取出一个推送到执行栈中执行, 这个过程一直循环重复, 故被称为 Event Loop


### 宏任务与微任务

在上面第二步中, 异步任务有分成 宏任务 和 微任务(区别是执行顺序不同)

宏任务: script 全部代码, setTimeout, setInterval, serImmediate, I/O(磁盘读写或网络通信), UI 渲染
微任务: process.nextTick, Promise.then(Promise 得到回调后的事件), Object.observe(废弃), MutationObserver

在 ES6 中, microtask 成为 jobs, 

在一次事件循环中, 首先 JS 会执行一个宏任务(全部 JS 代码), 执行完成后判断微任务队列中是否有微任务,
 - 如果有, 将它们依次全部执行完, 再开始下一个宏任务;
 - 如果没有, 跳到执行下一个宏任务

**优先级**

process.nextTick 高于 Promise
setTimeout 高于 setImmediate
